#!/usr/bin/env bash

# Health: A command-line RHEL system check tool written in bash 3.2+.
# https://github.com/zpiatt/health
#
# Copyright (C) 2024 Zac Piatt
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

readonly version="Health version: 1.7.3 - June 5, 2024"

usage() {
    printf "Usage: health [OPTION]... [DIRECTORY]...\n"
    printf "Display general system statisics and check for common errors.\n\n"
    printf "  -d,   display colorized disk space usage when greater than 90%%\n"
    printf "  -e,   parse dmesg for alerts, errors, etc. (may require sudo)\n"
    printf "  -f,   report 10 largest files in specified directory tree\n"
    printf "  -h,   display this help and exit\n"
    printf "  -i,   display colorized inodes usage when greater than 90%%\n"
    printf "  -k,   display kernel information; check for updates\n"
    printf "  -m,   check mounts for common errors\n"
    printf "  -n,   display basic network details\n"
    printf "  -o,   show users with open files (may require sudo)\n"
    printf "  -r,   display health on remote host\n"
    printf "  -s,   search for common file permission vulnerabilities\n"
    printf "  -u,   report 10 largest directories by inode usage\n"
    printf "  -v,   display version number and exit\n"
    printf "  -w,   show passwd info for specified user\n"
    printf "  -z,   display zombie process count, if any\n\n"
    printf "Full documentation <https://github.com/zpiatt/health>\n"
}

health() {
    local product_name sys_vendor

    printf "%bHostname:%b %s\n" "$blue" "$reset" "$(hostname)"
    get_network_info
    product_name=/sys/devices/virtual/dmi/id/product_name
    sys_vendor=/sys/devices/virtual/dmi/id/sys_vendor
    [[ -f "$product_name" && -f "$sys_vendor" ]] && {
        printf "%bServer Info:%b %s, %s\n" "$blue" "$reset" "$(< "$product_name")" "$(< "$sys_vendor")"; }
    [[ -f /etc/redhat-release ]] && {
        printf "%bLinux Version:%b %s\n" "$blue" "$reset" "$(< /etc/redhat-release)"; }
    printf "%bKernel Version:%b %s\n" "$blue" "$reset" "$(awk '{print $3}' /proc/version)"
    printf "%bUptime:%b %s\n" "$blue" "$reset" "$(uptime)"
    printf "%bUsers Currently Logged in:%b\n" "$blue" "$reset"; whotf
    printf "%bMemory Usage:%b\n%s\n" "$blue" "$reset" "$(free -h)"
    printf "%bTop 5 Processes by Memory:%b\n%s\n" "$blue" "$reset" \
        "$(ps -eo %mem,comm,pid --sort=-%mem | head -n 6)"
    printf "%bTop 5 Processes by CPU:%b\n%s\n" "$blue" "$reset" \
        "$(ps -eo pcpu,comm,pid --sort=-pcpu | head -n 6)"
    check_mounts
}

check_df() {
    local line status

    timeout 2 df &> /dev/null || { printf "%bHung mount detected%b\n" "$yellow" "$reset" >&2; return 1; }

    while read -r line; do
        case "$line" in
            *100%*) printf "%b%s%b\n" "$red" "$line" "$reset"; status=1 ;;
            *9?%*) printf "%b%s%b\n" "$yellow" "$line" "$reset"; status=1 ;;
        esac
    done < <(df "$1")

    return "${status:-0}"
}

dmesg_parse() {
    local level emerg crit alert err warn

    dmesg -V &> /dev/null || {
        printf "health: dmesg version insufficient\n" >&2
        printf "Try 'health -h' for more information.\n" >&2; return 1; }

    for level in emerg crit alert err warn; do
        readarray -t "$level" < <(dmesg -l "$level")
    done

    [[ -n "$emerg" ]] && printf "%bemergency messages%b: %d\n" "$red" "$reset" "${#emerg[@]}"
    [[ -n "$crit" ]] && printf "%bcritical messages%b: %d\n" "$red" "$reset" "${#crit[@]}"
    [[ -n "$alert" ]] && printf "%balert messages%b: %d\n" "$yellow" "$reset" "${#alert[@]}"
    [[ -n "$err" ]] && printf "%berror messages%b: %d\n" "$yellow" "$reset" "${#err[@]}"
    [[ -n "$warn" ]] && printf "%bwarning messages%b: %d\n" "$yellow" "$reset" "${#warn[@]}"
}

check_kernel() {
    local current_kernel latest_kernel check_yum available_kernel

    current_kernel=$(awk '{print $3}' /proc/version)
    check_yum=$(yum list updates kernel 2>&1)
    available_kernel=$(echo "$check_yum" | awk '/kernel/{print $2}')

    if [[ -n "$available_kernel" ]]; then
        printf "%bKernel version:%b (%bpending kernel updates%b)\n" "$blue" "$reset" "$yellow" "$reset"
        printf "  Available (yum update): \t%s\n" "$available_kernel"
    elif [[ "$check_yum" =~ "No matching Packages to list" ]]; then
        latest_kernel=$(rpm -q --last kernel | sed -n '1s/kernel-//;1s/ .*$//p')
        if [[ "$latest_kernel" == "$current_kernel" ]]; then
            printf "%bKernel version:%b (%bup-to-date%b)\n" "$blue" "$reset" "$green" "$reset"
        else
            printf "%bKernel version:%b (%bpending kernel updates%b)\n" "$blue" "$reset" "$yellow" "$reset"
            printf "  Latest installed kernel: \t%s\n" "$latest_kernel"
        fi
    else
        printf "%s\n" "$check_yum" >&2; return 1
    fi

    printf "  Current running kernel: \t%s\n" "$current_kernel"
}

check_mounts() {
    local mount error nfs_server

    printf "%bMounts & File Sytems:%b\n" "$blue" "$reset"
    while read -r mount; do
        findmnt "$mount" &> /dev/null || {
            printf "%b%s is declared in fstab but not mounted\n%b" "$yellow" "$mount" "$reset"
            error=true; }
    done < <(awk '!/^#/ && $2~/^[/]/ {print $2}' /etc/fstab)

    while read -r nfs_server; do
        timeout 1 showmount "${nfs_server%%:*}" &> /dev/null || {
            printf "  %s (%bpotential NFS error%b)\n" "${nfs_server%%:*}" "$yellow" "$reset"
            error=true; }
    done < <(awk '!/^#/ && $3~/nfs/{print $1}' /etc/fstab 2> /dev/null)

    if check_df "-Ti"; then
        check_df "-Th" || error=true
    else
        error=true
    fi

    [[ -z "$error" ]] && printf "No issues detected\n"
}

get_network_info() {
    local interface ip gateway dns dns_servers nfs_server

    printf "%bInterface(s):%b\n" "$blue" "$reset"
    while read -r interface ip; do
        printf "  %s - %s\n" "$interface" "$ip"
    done < <(ip route 2> /dev/null | awk '/src/{print $3, $9}')
    
    printf "%bDefault gateway:%b\n" "$blue" "$reset"
    gateway=$(ip route 2> /dev/null | awk '/default/{print $3}')
    if ping -W1 -c1 "$gateway" &> /dev/null; then
        printf "  %s (%breachable%b)\n" "$gateway" "$green" "$reset"
    else
        printf "  %s (%bunreachable%b)\n" "$gateway" "$yellow" "$reset"
    fi

    printf "%bDNS nameserver(s):%b\n" "$blue" "$reset"
    if grep "^DNS=" /etc/systemd/resolved.conf &> /dev/null; then
        readarray -t dns_servers < <(awk -F= '/^DNS=/ {print $2}' /etc/systemd/resolved.conf | xargs -n1)
    else
        readarray -t dns_servers < <(awk '/^nameserver/ {print $2}' /etc/resolv.conf)
    fi

    for dns in "${dns_servers[@]}"; do
        if ping -W1 -c1 "$dns" &> /dev/null; then
            printf "  %s (%breachable%b)\n" "$dns" "$green" "$reset"
        else
            printf "  %s (%bpotential DNS error%b)\n" "$dns" "$yellow" "$reset"
        fi
    done

    printf "%bNFS server(s):%b\n" "$blue" "$reset"
    while read -r nfs_server; do
        printf "  %s\n" "$nfs_server"
    done < <(awk -F: '!/^#/&&/nfs/{print $1}' /etc/fstab 2> /dev/null)
}

users_with_open_files() {
    local all_users id name uid gid full_name

    readarray -t all_users < <(lsof -Fnu | awk '/^u/&&!x[$0]++')

    printf "%-24.24s%-12.12s%-12.12s%-32.32s\n" "NAME" "UID" "GID" "FULL NAME"
    for id in "${all_users[@]}"; do
        while read -r name uid gid full_name; do
            printf "%-24.24s%-12.12s%-12.12s%-32.32s\n" "$name" "$uid" "$gid" "$full_name" 
        done < <(getent passwd "${id:1}" | awk -F: '{print $1, $3, $4, $5}')
    done
}

file_vulnerability() {
    local world_write setbits

    world_write="$(find "$dir" ! -type l -perm -002)"
    setbits="$(find "$dir" -perm -4000 -o -perm -2000)"

    [[ -n "$world_write" ]] && printf "%bWorld writable files:%b\n%s\n" "$blue" "$reset" "$world_write"
    [[ -n "$setbits" ]] && printf "%bFiles with setgids/setuids:%b\n%s\n" "$blue" "$reset" "$setbits"
}

whotf() {
    local user stats full_name

    while read -r user stats; do
        full_name=$(getent passwd "$user" | awk -F: '{print $5}')
        printf "%-32.32s %s (%s)\n" "${full_name:-$user}" "$stats" "$user"
    done < <(who)
}

get_args() {
    local option

    while getopts ':defhikmnor:suvw:z' option; do
        case "$option" in
            d|e|f|i|k|m|n|o|s|u|z) args_array+=("$option") ;;
            h) usage; exit 0 ;;
            r) ssh -qt "$OPTARG" "bash -s" < "$0" ;;
            v) printf "%s\n" "$version"; exit 0 ;;
            w) args_array+=("$option"); user="$OPTARG" ;;
            ?)
                printf "health: invalid option -- '%s'\n" "$OPTARG" >&2
                printf "Try 'health -h' for more information.\n" >&2; exit 2
            ;;
        esac
    done
    shift "$(( OPTIND -1 ))"

    if [[ -z "${1:-}" ]]; then
       dir="$(pwd)"
    elif [[ ! -d "$1" ]]; then
        printf "'%s': not a valid path.\n" "$1" >&2; exit 2
    else
        if [[ -n "${args_array[@]}" ]]; then
            dir="$1"
        else
            printf "health: invalid option -- '%s'\n" "$*" >&2
            printf "Try 'health -h' for more information.\n" >&2; exit 2
        fi
    fi
}

main() {
    green='\033[38;5;46m'
    yellow='\033[38;5;226m'
    blue='\033[38;5;33m'
    red='\033[38;5;160m'
    reset='\033[0m'

    if [[ "$#" -eq 0 ]]; then
        health; exit 0
    else
        get_args "$@"
    fi

    for arg in "${args_array[@]}"; do
        [[ "$arg" == "d" ]] && check_df "-Th"
        [[ "$arg" == "e" ]] && dmesg_parse
        [[ "$arg" == "f" ]] && find "$dir" -xdev -type f -print0 | xargs -0 du -Sh | sort -rh | head
        [[ "$arg" == "i" ]] && check_df "-Ti"
        [[ "$arg" == "k" ]] && check_kernel
        [[ "$arg" == "m" ]] && check_mounts
        [[ "$arg" == "n" ]] && get_network_info
        [[ "$arg" == "o" ]] && users_with_open_files
        [[ "$arg" == "s" ]] && file_vulnerability
        [[ "$arg" == "u" ]] && find "$dir" -xdev -printf '%h\n' | sort | uniq -c | sort -rn | head
        [[ "$arg" == "w" ]] && getent passwd "$user"
        [[ "$arg" == "z" ]] && ps axo stat | awk 'BEGIN{i=0}/Z/{i++;}END{print i}'
    done

    return 0
}

main "$@"
